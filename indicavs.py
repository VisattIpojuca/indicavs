import streamlit as st
import pandas as pd
import plotly.express as px
from datetime import datetime
import unicodedata # M√≥dulo para normaliza√ß√£o de caracteres

# ========== CONFIGURA√á√ÉO GERAL ==========
st.set_page_config(page_title="üìä Dashboard Epidemiol√≥gico", layout="wide")

st.title("üìä Dashboard Epidemiol√≥gico Interativo")
st.caption("Fonte: Google Sheets - Atualiza√ß√£o autom√°tica")

# Dicion√°rio FINAL para padronizar nomes de colunas no DataFrame LIMPO
# CHAVES: Nomes de colunas no DataFrame AP√ìS a limpeza universal (ex: 'CLASSIFICACAO' ou 'SEMANA_EPIDEMIOLOGICA_2')
# VALORES: Nomes finais usados no c√≥digo (limpos e padronizados)
FINAL_RENAME_MAP = {
    # Padroniza√ß√£o de duplicatas e varia√ß√µes de SE (ap√≥s limpeza):
    'SEMANA_EPIDEMIOLOGICA_2': 'SEMANA_EPIDEMIOLOGICA',
    'SEMANA_EPIDEMIOLOGICA': 'SEMANA_EPIDEMIOLOGICA', # Garante que a vers√£o simples tamb√©m mapeie para o nome final
    
    # Padroniza√ß√£o de datas (ap√≥s limpeza):
    'DATA_DE_NOTIFICACAO': 'DATA_NOTIFICACAO',
    'DATA_PRIMEIROS_SINTOMAS': 'DATA_SINTOMAS',
    
    # Padroniza√ß√£o de abrevia√ß√µes e typos (ap√≥s limpeza):
    'FA': 'FAIXA_ETARIA', 
    'BAIRRO_RESIDENCIA': 'BAIRRO',
    'EVOLUCAO_DO_CASO': 'EVOLUCAO',
    'CLASSIFICACAO': 'CLASSIFICACAO_FINAL', # Corrige o 'CLASSIFCA√á√ÉO' lido e limpo (CLASSIFICACAO) para o nome final
    'RACA_COR': 'RACA_COR',
    'ESCOLARIDADE': 'ESCOLARIDADE',
    'DISTRITO': 'DISTRITO'
}

# CHAVE DE ORDENA√á√ÉO MANUAL PARA O NOVO PADR√ÉO DE FAIXA ET√ÅRIA
ORDEM_FAIXA_ETARIA = [
    '1 a 4 anos', '5 a 9 anos', '10 a 14 anos', '15 a 19 anos', 
    '20 a 39 anos', '40 a 59 anos', '60 anos ou mais', 'IGNORADO'
]

# DICION√ÅRIO PARA AGRUPAR E PADRONIZAR AS FAIXAS ET√ÅRIAS ANTIGAS PARA AS NOVAS
MAPEAMENTO_FAIXA_ETARIA = {
    '0 a 4': '1 a 4 anos', '1 a 4': '1 a 4 anos', '5 a 9': '5 a 9 anos', 
    '10 a 14': '10 a 14 anos', '15 a 19': '15 a 19 anos',
    '20 a 29': '20 a 39 anos', '30 a 39': '20 a 39 anos',
    '40 a 49': '40 a 59 anos', '50 a 59': '40 a 59 anos',
    '60 a 69': '60 anos ou mais', '70 a 79': '60 anos ou mais', 
    '80 ou mais': '60 anos ou mais', 'IGNORADO': 'IGNORADO',
}

# FUN√á√ÉO DE LIMPEZA DE COLUNAS: CORRE√á√ÉO DEFINITIVA COM UNICODE NORMALIZATION
def limpar_nome_coluna(col):
    # 1. Unicode Normalization (NFKD): Trata acentos, cedilhas e caracteres ocultos.
    col_normalized = unicodedata.normalize('NFKD', col).encode('ascii', 'ignore').decode('utf-8')
    
    # 2. Converte para mai√∫sculas e substitui espa√ßos e s√≠mbolos por underscore
    col_limpa = col_normalized.strip().upper().replace(' ', '_').replace('/', '_').replace('-', '_')
    
    return col_limpa


# ========= FUN√á√ÉO DE CARREGAR DADOS (FLUXO ROBUSTO) =========
@st.cache_data
def carregar_dados():
    url = "https://docs.google.com/spreadsheets/d/1bdHetdGEXLgXv7A2aGvOaItKxiAuyg0Ip0UER1BjjOg/export?format=csv"
    
    try:
        df = pd.read_csv(url)
    except Exception as e:
        st.error(f"‚ùå Erro de conex√£o. Verifique o compartilhamento da planilha.")
        st.stop()
        
    
    # --- Passo 1: Limpeza Universal de Nomes de Colunas ---
    # Aplica a limpeza robusta em TODAS as colunas do DataFrame
    df.columns = [limpar_nome_coluna(col) for col in df.columns] 

    # --- Passo 2: Padroniza√ß√£o Final de Nomes (Resolve Duplicatas/Typos) ---
    rename_dict = {}
    for k_limpo, v_final in FINAL_RENAME_MAP.items():
        if k_limpo in df.columns:
            rename_dict[k_limpo] = v_final
            
    df.rename(columns=rename_dict, inplace=True)
    
    # --- Passo 3: Limpeza de Colunas Duplicadas (Ex: Duas DATA_NOTIFICACAO) ---
    # O Pandas, ao renomear, pode deixar as colunas que n√£o foram mapeadas
    # mas que tinham nomes id√™nticos (ap√≥s limpeza) ainda existindo.
    # Exclu√≠mos as colunas que est√£o no mapa de renomea√ß√£o, mas que
    # n√£o s√£o o nome final desejado (para evitar duplicatas).
    colunas_a_manter = sorted(list(set(df.columns)))
    
    df = df[colunas_a_manter]

    # --- PADRONIZA√á√ÉO E AGRUPAMENTO DA FAIXA ET√ÅRIA ---
    if 'FAIXA_ETARIA' in df.columns:
        df['FAIXA_ETARIA'] = df['FAIXA_ETARIA'].astype(str).str.strip()
        df['FAIXA_ETARIA'] = df['FAIXA_ETARIA'].replace(MAPEAMENTO_FAIXA_ETARIA)
        df['FAIXA_ETARIA'] = df['FAIXA_ETARIA'].fillna('IGNORADO')
        
    # Converter datas
    for col in ['DATA_NOTIFICACAO', 'DATA_SINTOMAS']:
        if col in df.columns:
            # Garante que o nome final existe antes de tentar converter
            df[col] = pd.to_datetime(df[col], errors="coerce")

    return df

df = carregar_dados()

if df.empty:
    st.warning("O DataFrame est√° vazio.")
    st.stop()


# ========= FILTROS NA BARRA LATERAL (FAIXA ET√ÅRIA ORDENADA) =========
st.sidebar.header("üîé Filtros")

df_filtrado = df.copy() 

# FILTRO CLASSIFICA√á√ÉO FINAL (NO TOPO)
if 'CLASSIFICACAO_FINAL' in df_filtrado.columns:
    classificacoes = st.sidebar.multiselect("Classifica√ß√£o Final", df['CLASSIFICACAO_FINAL'].dropna().unique())
    if classificacoes:
        df_filtrado = df_filtrado[df_filtrado['CLASSIFICACAO_FINAL'].isin(classificacoes)]
        

# --- Outros Filtros Categ√≥ricos ---

# FILTRO DE SEMANA EPIDEMIOL√ìGICA (AGORA EST√ÅVEL)
if 'SEMANA_EPIDEMIOLOGICA' in df_filtrado.columns: # CHECK DE SEGURAN√áA
    semanas = st.sidebar.multiselect("Semana Epidemiol√≥gica", sorted(df['SEMANA_EPIDEMIOLOGICA'].dropna().unique()))
    if semanas:
        df_filtrado = df_filtrado[df_filtrado['SEMANA_EPIDEMIOLOGICA'].isin(semanas)]
else:
    st.sidebar.warning("Coluna 'Semana Epidemiol√≥gica' n√£o encontrada. Verifique o nome na planilha.")


if 'SEXO' in df_filtrado.columns:
    sexos = st.sidebar.multiselect("Sexo", df['SEXO'].dropna().unique())
    if sexos:
        df_filtrado = df_filtrado[df_filtrado['SEXO'].isin(sexos)]

# Ordena√ß√£o da Faixa Et√°ria
if 'FAIXA_ETARIA' in df_filtrado.columns:
    faixas_presentes = df['FAIXA_ETARIA'].dropna().unique().tolist()
    
    faixas_ordenadas = [f for f in ORDEM_FAIXA_ETARIA if f in faixas_presentes]
    
    faixas = st.sidebar.multiselect("Faixa Et√°ria", faixas_ordenadas) 
    if faixas:
        df_filtrado = df_filtrado[df_filtrado['FAIXA_ETARIA'].isin(faixas)]

# FILTRO DE EVOLU√á√ÉO DO CASO 
if 'EVOLUCAO' in df_filtrado.columns:
    evolucoes = st.sidebar.multiselect("Evolu√ß√£o do Caso", df['EVOLUCAO'].dropna().unique())
    if evolucoes:
        df_filtrado = df_filtrado[df_filtrado['EVOLUCAO'].isin(evolucoes)]

if 'ESCOLARIDADE' in df_filtrado.columns:
    escolaridades = st.sidebar.multiselect("Escolaridade", df['ESCOLARIDADE'].dropna().unique())
    if escolaridades:
        df_filtrado = df_filtrado[df_filtrado['ESCOLARIDADE'].isin(escolaridades)]

if 'BAIRRO' in df_filtrado.columns:
    bairros = st.sidebar.multiselect("Bairro", sorted(df['BAIRRO'].dropna().unique()))
    if bairros:
        df_filtrado = df_filtrado[df_filtrado['BAIRRO'].isin(bairros)]
        
# Verifica se o DataFrame filtrado est√° vazio
if df_filtrado.empty:
    st.warning("Nenhum dado encontrado com os filtros selecionados.")
    st.stop()


# ========= INDICADORES PRINCIPAIS (CARDS) =========
st.header("Resumo dos Indicadores")

confirmados = 0 
obitos = 0
descartados = 0 

col0, col1, col2, col3, col4 = st.columns(5) 

total_filtrado = len(df_filtrado)
col1.metric("Notifica√ß√µes no per√≠odo", total_filtrado) 

if 'CLASSIFICACAO_FINAL' in df_filtrado.columns:
    confirmados = (df_filtrado['CLASSIFICACAO_FINAL'].astype(str).str.upper().str.strip() == "CONFIRMADO").sum()
    descartados = (df_filtrado['CLASSIFICACAO_FINAL'].astype(str).str.upper().str.strip() == "DESCARTADO").sum()
    col2.metric("Confirmados", confirmados)
    col3.metric("Descartados", descartados) 

if 'EVOLUCAO' in df_filtrado.columns:
    obitos = (df_filtrado['EVOLUCAO'].astype(str).str.upper().str.contains("√ìBITO", na=False)).sum()

if confirmados > 0:
    letalidade = (obitos / confirmados) * 100
    col4.metric("Taxa de Letalidade (%)", f"{letalidade:.2f}% ({obitos} √≥bitos)")
else:
    col4.metric("Taxa de Letalidade (%)", "N/A")


# ========= GR√ÅFICOS =========

st.subheader("üìà An√°lise Temporal e Geogr√°fica")
col_graf1, col_graf2 = st.columns(2)

# --- 1. Casos por Semana Epidemiol√≥gica ---
if 'SEMANA_EPIDEMIOLOGICA' in df_filtrado.columns:
    df_semanal = df_filtrado.groupby("SEMANA_EPIDEMIOLOGICA").size().reset_index(name="Casos")
    fig_sem = px.line(
        df_semanal, 
        x="SEMANA_EPIDEMIOLOGICA", 
        y="Casos", 
        markers=True,
        title="Casos por Semana Epidemiol√≥gica"
    )
    col_graf1.plotly_chart(fig_sem, use_container_width=True)

# --- 2. Distribui√ß√£o por Distrito ---
if 'DISTRITO' in df_filtrado.columns:
    df_distrito = df_filtrado['DISTRITO'].value_counts().reset_index()
    df_distrito.columns = ['Distrito', 'Casos'] 
    
    fig_distrito = px.bar(
        df_distrito, 
        x='Distrito', 
        y='Casos',
        title="Distribui√ß√£o de Casos por Distrito"
    )
    col_graf2.plotly_chart(fig_distrito, use_container_width=True)

# --- 3. Distribui√ß√£o por Bairro ---
st.subheader("üèòÔ∏è Distribui√ß√£o das notifica√ß√µes por Bairro")
if 'BAIRRO' in df_filtrado.columns:
    df_bairro = df_filtrado['BAIRRO'].value_counts().reset_index()
    df_bairro.columns = ['Bairro', 'Casos'] 
    
    fig_bairro = px.bar(
        df_bairro.head(15), 
        x='Bairro', 
        y='Casos',
        title="Top 15 Bairros por Casos Notificados"
    )
    st.plotly_chart(fig_bairro, use_container_width=True)

# --- 4. Rela√ß√£o Ra√ßa/Cor vs. Escolaridade ---
st.subheader("üéì Perfil Social: Ra√ßa/Cor vs. Escolaridade")
if 'RACA_COR' in df_filtrado.columns and 'ESCOLARIDADE' in df_filtrado.columns:
    df_cruzado = df_filtrado.groupby(['RACA_COR', 'ESCOLARIDADE']).size().reset_index(name='Casos')

    fig_cruzado = px.bar(
        df_cruzado,
        x='RACA_COR',
        y='Casos',
        color='ESCOLARIDADE',
        barmode='group',
        title='Casos por Ra√ßa/Cor e Escolaridade'
    )
    st.plotly_chart(fig_cruzado, use_container_width=True)


# --- 5. Sintomas e Comorbidades Mais Frequentes ---
st.subheader("üß© Sintomas e Comorbidades")
sintomas_e_comorbidades = [
    "FEBRE", "MIALGIA", "CEFALEIA", "EXANTEMA", "VOMITO", "NAUSEA",
    "DOR_COSTAS", "CONJUNTVITE", "ARTRITE", "ARTRALGIA", "PETEQUIAS",
    "LEUCOPENIA", "LA√áO", "DOR_RETRO", "DIABETES", "HEMATOLOGICAS",
    "HEPATOPATIAS", "RENAL", "HIPERTENS√ÉO", "ACIDO_PEPT", "AUTO_IMUNE"
]

presenca_data = []
for s in sintomas_e_comorbidades:
    s_limpa = limpar_nome_coluna(s)
    
    # Busca a coluna pelo nome limpo gerado pelo processo de limpeza geral
    if s_limpa in df_filtrado.columns:
        count = (df_filtrado[s_limpa].astype(str).str.upper().str.strip() == "SIM").sum()
        if count > 0:
            nome_display = s.replace('_', ' ').capitalize()
            presenca_data.append({"Item": nome_display, "Casos": count})

if presenca_data:
    df_presenca = pd.DataFrame(presenca_data)
    
    fig_sintomas = px.bar(
        df_presenca.sort_values(by="Casos", ascending=True), 
        y="Item", 
        x="Casos", 
        orientation='h',
        title="Frequ√™ncia de Manifesta√ß√µes/Comorbidades (Resposta 'Sim')"
    )
    st.plotly_chart(fig_sintomas, use_container_width=True)
else:
    st.info("Nenhuma manifesta√ß√£o ou comorbidade 'SIM' encontrada no per√≠odo filtrado.")


# --- 6. Distribui√ß√£o por Sexo e Faixa Et√°ria (Ordenada) ---
st.subheader("üë• Perfil Demogr√°fico")
if 'SEXO' in df_filtrado.columns and 'FAIXA_ETARIA' in df_filtrado.columns:
    
    faixas_presentes_no_grafico = df_filtrado['FAIXA_ETARIA'].dropna().unique().tolist()
    faixas_para_grafico = [f for f in ORDEM_FAIXA_ETARIA if f in faixas_presentes_no_grafico]

    fig_demog = px.histogram(
        df_filtrado, 
        x="FAIXA_ETARIA", 
        color="SEXO", 
        barmode="group",
        title="Casos por Faixa Et√°ria e Sexo"
    )
    # Define a ordem do eixo X do gr√°fico (usando a nova ordem padronizada)
    fig_demog.update_xaxes(categoryorder='array', categoryarray=faixas_para_grafico)
    
    st.plotly_chart(fig_demog, use_container_width=True)


# ========= DOWNLOAD DOS DADOS FILTRADOS =========
st.download_button(
    "üì• Baixar dados filtrados (CSV)",
    data=df_filtrado.to_csv(index=False).encode("utf-8"),
    file_name="dados_filtrados_epidemiologia.csv",
    mime="text/csv"
)

st.caption("Desenvolvido para Vigil√¢ncia em Sa√∫de.")